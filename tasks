1. Дана функция (статический метод) на языке Java:
static int myfunc(int[] a) {
     int x = 0;
     for (int i = 0; i < a.length; i++) {
         for (int j = i; j < a.length; j++) {
             if (a[j] != a[i]) {
                 if (j - i > x) {
                     x = j - i;
                 }
                 i = j - 1;  // Данная строка не влияет на работу скрипта
                 break;
             }
         }
     }
     return x;
}

Что делает эта функция?
Ответ: Метод myfunc() возвращает максимальное количество повторяющихся элементов в массиве.

Какая у неё алгоритмическая сложность?
Ответ: O(N*N) квадратичная 

Есть ли в этой функции логические дефекты? Если да, то какие?
Ответ: Есть. Если повторяющиеся элементы в конце массива тогда возвращается 1

Можно ли как-то улучшить данный код? Если да, напишите улучшенный вариант.
Ответ: Да можно. Мой вариант:
public class Test1_solve {
    public static void main(String[] args) {
        int[] a = {1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3};
        System.out.println(myfunc(a));
    }
    static int myfunc(int[] a) {
        if (a.length <= 1) return 0;
        int x = 0;
        int prev = 0;
        int next = 1;

        while (prev < next && next < a.length) {
            if (a[prev] != a[next]) {
                prev++;
                next++;
            } else {
                next++;
                x = Math.max(x, next - prev);
            }
        }
        return x; } }

Какая алгоритмическая сложность у вашего варианта?
Ответ: Алгоритмическая сложность моего варианта O(n)

2. Даны векторы A и B с координатами, соответственно, (x1, y1, z1) и
(x2, y2, z2). Как узнать, перпендикулярны ли они друг другу?
Ответ: Узнать можно по формуле: Если x1*x2 + y1*y2 + z1*z2 = 0, тогда перпендикулярные
public class Perpendicular {
    public static void main(String[] args) {
        Line l1 = new Line(3,4,5);
        Line l2 = new Line(4,5,6);
        System.out.println(check(l1, l2));
    }
    private static boolean check(Line a, Line b){
        int res = a.x * b.x + a.y * b.y + a.z * b.z;
        return res == 0;
    }
}
class Line {
    int x;
    int y;
    int z;
    public Line(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;     }  }
 
 3. Один поезд выехал из пункта А в пункт Б, одновременно с ним другой
поезд выехал из пункта Б в пункт А. Поезда двигаются с постоянными
скоростями.
Они встретились в 15 часов, машинисты на ходу помахали друг другу из
окон, и продолжили двигаться к своим конечным пунктам.
Первый поезд доехал до своего пункта назначения через 9 часов после
встречи, а второй до своего - через 16 часов после встречи. Во сколько
они стартовали?
Ответ: 
s1 расстояние прошедшее 1 поездом до встречи s1 = v1 * t 
s2 расстояние прошедшее 2 поездом до встречи s2 = v2 * t 
t время до встречи
Весть путь s = s1 + s2
Оставшийся путь для 1 поезда v1*9
Оставшийся путь для 1 поезда v2*16
s = v1*9 + v2*16
s= v1*t + v2*t
Два уравнения 3 неизвестных
Искомое время 15 - t
Предполагаю искомое время 15 - (16-9) = 8 часов

4. Казино предлагает вам сыграть в игру: вы бросаете два 6-гранных
игральных кубика, и получаете приз в зависимости от выпавшей на них
суммы очков:
12 очков: 100 рублей
11 очков: 90 рублей
10 очков: 80 рублей
9 очков: 50 рублей
от 2 до 8 очков: 0 рублей
Сколько вы согласны заплатить за возможность один раз сыграть в такую игру?
Ответ:
12 очков - только 1 комбинация 6+6
11 очков - только 1 комбинация 6+5
10 очков - только 2 комбинации 5+5 и 6+4
9 очков - только 2 комбинации 5+4 и 6+3 самая выгодная комбинация, большая вероятность выпадения 3, 4, 5, 6 или больших номиналов
от 2 до 8 очков  1+1 1+2 1+3 1+4 1+5 1+6 2+2 2+3 2+4 2+5 2+6 3+4 3+5 4+4 
Согласен заплатить 50 руб, есть вероятность выиграть 50 и больше.


5. Напишите функцию, которая принимает на вход массив строк, и
возвращает такой же массив, но без тех элементов, которых в исходном
массиве было чётное количество.
Решение должно быть оптимизировано по скорости работы. Писать можно на
любом из популярных высокоуровневых языков программирования (выбранный
язык нужно указать).
Оцените алгоритмическую сложность своей реализации.
Ответ: Алгоритм на Java, сложность ~ O(2n)
import java.util.ArrayList;
import java.util.HashMap;

public class StringArrDuplicate {
    public static void main(String[] args) {
        String[] str = {"aba", "bobik", "aba", "aboba", "biba", "aba", "biba"};
        System.out.println(arrayWithoutDuplicates(str));

    }
    private static ArrayList<String> arrayWithoutDuplicates(String[] arr){
        ArrayList<String> list = new ArrayList<>();

        if (arr.length == 1) {
            list.add(arr[0]);
            return list;
        }

        HashMap<String, Integer> map = new HashMap<>();

        for (String s : arr) {
            if (!map.containsKey(s)) {
                map.put(s, 1);
            } else {
                map.put(s, map.get(s) + 1);
            }
        }

        for (String key : map.keySet()) {
            if (map.get(key) != 2) {
                list.add(key);
            }
        }
        return list;
    }  } 
